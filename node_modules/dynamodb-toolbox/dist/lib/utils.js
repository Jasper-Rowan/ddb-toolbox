"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBinary = exports.isArrayOfSameType = exports.typeOf = exports.transformAttr = exports.conditionError = exports.keyTypeError = exports.typeError = exports.error = exports.isEmpty = exports.hasValue = exports.toDynamoBigInt = exports.toBool = exports.isDynamoDbKeyType = exports.isDynamoDbType = exports.validKeyTypes = exports.validTypes = void 0;
const util_dynamodb_1 = require("@aws-sdk/util-dynamodb");
exports.validTypes = [
    'string',
    'boolean',
    'number',
    'bigint',
    'list',
    'map',
    'binary',
    'set'
];
exports.validKeyTypes = ['string', 'number', 'bigint', 'binary'];
const isDynamoDbType = (value) => exports.validTypes.includes(value);
exports.isDynamoDbType = isDynamoDbType;
const isDynamoDbKeyType = (value) => exports.validKeyTypes.includes(value);
exports.isDynamoDbKeyType = isDynamoDbKeyType;
// Boolean conversion
const toBool = (val) => typeof val === 'boolean'
    ? val
    : ['false', '0', 'no'].includes(String(val).toLowerCase())
        ? false
        : Boolean(val);
exports.toBool = toBool;
const toDynamoBigInt = (value) => (0, util_dynamodb_1.unmarshall)({ valueToUnmarshall: { N: value.toString() } }, { wrapNumbers: true }).valueToUnmarshall.value;
exports.toDynamoBigInt = toDynamoBigInt;
// has value shortcut
const hasValue = (val) => val !== undefined && val !== null;
exports.hasValue = hasValue;
// isEmpty object shortcut
const isEmpty = (val) => val === undefined || (typeof val === 'object' && Object.keys(val).length === 0);
exports.isEmpty = isEmpty;
// Inline error handler
const error = (err) => {
    throw new Error(err);
};
exports.error = error;
// Standard type error
const typeError = (field) => {
    (0, exports.error)(`Invalid or missing type for '${field}'. ` +
        `Valid types are '${exports.validTypes.slice(0, -1).join(`', '`)}',` +
        ` and '${exports.validTypes.slice(-1)}'.`);
};
exports.typeError = typeError;
// Key type error
const keyTypeError = (field) => {
    (0, exports.error)(`Invalid or missing type for '${field}'. ` +
        `Valid types for partitionKey and sortKey are 'string','number' and 'binary'`);
};
exports.keyTypeError = keyTypeError;
// Condition error
const conditionError = (op) => (0, exports.error)(`You can only supply one sortKey condition per query. Already using '${op}'`);
exports.conditionError = conditionError;
// Transform attribute values
const transformAttr = (mapping, value, data) => {
    value = mapping.transform ? mapping.transform(value, data) : value;
    return mapping.prefix || mapping.suffix
        ? `${mapping.prefix || ''}${value}${mapping.suffix || ''}`
        : value;
};
exports.transformAttr = transformAttr;
function typeOf(data) {
    if (data === null && typeof data === 'object') {
        return 'null';
    }
    else if (data !== undefined && isBinary(data)) {
        return 'Binary';
    }
    else if (data !== undefined && data.constructor) {
        return data.constructor.name.toLowerCase();
    }
    else if (data !== undefined && typeof data === 'object') {
        // this object is the result of Object.create(null), hence the absence of a
        // defined constructor
        return 'Object';
    }
    else {
        return 'undefined';
    }
}
exports.typeOf = typeOf;
function isArrayOfSameType(array) {
    const length = array.length;
    if (length <= 1) {
        return true;
    }
    const firstType = typeOf(array[0]);
    return array.slice(1).every((el) => typeOf(el) === firstType);
}
exports.isArrayOfSameType = isArrayOfSameType;
function isBinary(data) {
    const binaryTypes = [
        'ArrayBuffer',
        'Blob',
        'Buffer',
        'DataView',
        'File',
        'Int8Array',
        'Uint8Array',
        'Uint8ClampedArray',
        'Int16Array',
        'Uint16Array',
        'Int32Array',
        'Uint32Array',
        'Float32Array',
        'Float64Array',
        'BigInt64Array',
        'BigUint64Array',
    ];
    if (data === null || data === void 0 ? void 0 : data.constructor) {
        return binaryTypes.includes(data.constructor.name);
    }
    return false;
}
exports.isBinary = isBinary;
