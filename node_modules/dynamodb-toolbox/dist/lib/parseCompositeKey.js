"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const parseMapping_1 = __importDefault(require("./parseMapping"));
const parseCompositeKey = (field, config, track, schema) => {
    var _a;
    if (config.length >= 2 && config.length <= 3) {
        const link = schema[config[0]] ? config[0] : (0, utils_1.error)(`'${field}' must reference another field`);
        const pos = parseInt(config[1].toString()) === config[1]
            ? config[1]
            : (0, utils_1.error)(`'${field}' position value must be numeric`);
        // ðŸ”¨ TOIMPROVE: Prevent casting if possible
        const sub_config = (!config[2]
            ? { type: 'string' }
            : ['string', 'number', 'boolean'].includes(config[2].toString())
                ? { type: config[2] }
                : ((_a = config[2]) === null || _a === void 0 ? void 0 : _a.constructor) === Object
                    ? config[2]
                    : (0, utils_1.error)(`'${field}' type must be 'string', 'number', 'boolean' or a configuration object`));
        // Add linked fields
        if (!track.linked[link])
            track.linked[link] = [];
        track.linked[link][pos] = field;
        // Merge/validate extra config data and add link and pos
        return Object.assign({
            [field]: Object.assign({ save: true }, // default save to true
            (0, parseMapping_1.default)(field, sub_config, track)[field], { link, pos })
        }, sub_config.alias
            ? {
                [sub_config.alias]: Object.assign({}, sub_config, { map: field })
            }
            : {});
    }
    else {
        (0, utils_1.error)(`Composite key configurations must have 2 or 3 items`);
    }
};
exports.default = parseCompositeKey;
